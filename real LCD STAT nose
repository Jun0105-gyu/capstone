import cv2
import numpy as np
import mediapipe as mp
from flask import Flask, jsonify, request
import threading
import time

app = Flask(__name__)

# 초기 상태
start_time = None
elapsed_time = 0
is_running = False
drowsiness_detected = False
drowsy_reason = ""
lock = threading.Lock()

# 버튼 상태
button_start = False
button_stop = False
button_reset = False

# EAR 계산 함수
def calculate_ear(landmarks):
    A = np.linalg.norm(np.array(landmarks[1]) - np.array(landmarks[5]))
    B = np.linalg.norm(np.array(landmarks[2]) - np.array(landmarks[4]))
    C = np.linalg.norm(np.array(landmarks[0]) - np.array(landmarks[3]))
    ear = (A + B) / (2.0 * C)
    return ear

# 손 이동 평균 계산 함수
def average_hand_movement(movement_history):
    if len(movement_history) == 0:
        return 0
    return sum(movement_history) / len(movement_history)

# 졸음 인식 루프
def drowsiness_detection_loop():
    global drowsiness_detected, drowsy_reason, is_running

    cap = cv2.VideoCapture(0)
    mp_face = mp.solutions.face_mesh
    mp_hands = mp.solutions.hands
    face = mp_face.FaceMesh()
    hands = mp_hands.Hands(max_num_hands=1)

    eye_thresh = 0.21
    eye_counter = 0
    hand_counter = 0
    head_counter = 0

    ear_history = []
    movement_history = []
    nose_y_history = []

    while True:
        ret, frame = cap.read()
        if not ret:
            continue

        rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
        result_face = face.process(rgb)
        result_hands = hands.process(rgb)

        h, w, _ = frame.shape

        ear = None
        dy = None
        movement = None

        if result_face.multi_face_landmarks:
            for landmarks in result_face.multi_face_landmarks:
                coords = [(int(p.x * w), int(p.y * h)) for p in landmarks.landmark]

                left_eye = [coords[i] for i in [362, 385, 387, 263, 373, 380]]
                right_eye = [coords[i] for i in [33, 160, 158, 133, 153, 144]]
                ear = (calculate_ear(left_eye) + calculate_ear(right_eye)) / 2.0
                print(f"[EYE] EAR: {ear:.3f}")

                nose = coords[1]
                nose_y_history.append(nose[1])
                if len(nose_y_history) > 150:
                    nose_y_history.pop(0)

                if len(nose_y_history) >= 2:
                    dy = nose_y_history[-1] - nose_y_history[0]
                    print(f"[HEAD] DY: {dy:.2f}")

        if result_hands.multi_hand_landmarks:
            for hand_landmarks in result_hands.multi_hand_landmarks:
                lm = hand_landmarks.landmark
                x = int(lm[10].x * w)
                y = int(lm[10].y * h)
                movement_history.append((x, y))
                if len(movement_history) > 150:
                    movement_history.pop(0)

        if len(movement_history) >= 2:
            dis = 0
            for i in range(1, len(movement_history)):
                dis += np.linalg.norm(np.array(movement_history[i]) - np.array(movement_history[i - 1]))
            movement = dis / (len(movement_history) - 1)
            print(f"[HAND] Movement: {movement:.2f}")

        if not is_running:
            time.sleep(1)
            continue

        # EAR 기준
        if ear is not None and ear < eye_thresh:
            ear_history.append(ear)
        else:
            ear_history.clear()

        if len(ear_history) >= 15:
            eye_counter += 1
        else:
            eye_counter = 0

        # DY 기준
        if dy is not None and dy > 20:
            head_counter += 1
        else:
            head_counter = 0

        # HAND 기준
        if movement is not None and movement < 50:
            hand_counter += 1
        else:
            hand_counter = 0

        if hand_counter >= 5:
            print("[HAND] Low movement detected for 5 seconds")

        if (hand_counter >= 5 and eye_counter >= 5) or (hand_counter >= 5 and head_counter >= 5):
            if not drowsiness_detected:
                drowsiness_detected = True
                drowsy_reason = "HAND + EYE" if eye_counter >= 5 else "HAND + HEAD"
                print("=== DROWSINESS DETECTED:", drowsy_reason, "===")

        time.sleep(1)

# 타이머 루프
def timer_loop():
    global start_time, elapsed_time, is_running
    while True:
        with lock:
            if is_running:
                elapsed_time = time.time() - start_time
        time.sleep(1)

# 버튼 모니터링 루프
def monitor_buttons():
    pass  # 실제 GPIO 버튼 제어는 생략

# API: 타이머 시작
@app.route("/start")
def start():
    global is_running, start_time, elapsed_time
    if not is_running:
        start_time = time.time() - elapsed_time
        is_running = True
        print("[API] Timer started")
    return "started"

# API: 타이머 정지
@app.route("/stop")
def stop():
    global is_running, elapsed_time
    is_running = False
    print("[API] Timer stopped")
    return "stopped"

# API: 타이머 초기화
@app.route("/reset")
def reset():
    global is_running, elapsed_time, drowsiness_detected, drowsy_reason
    is_running = False
    elapsed_time = 0
    drowsiness_detected = False
    drowsy_reason = ""
    print("[RESET] System reset")
    return "reset"

# API: 타이머 값 반환
@app.route("/get_time")
def get_time():
    total = int(elapsed_time)
    h = total // 3600
    m = (total % 3600) // 60
    s = total % 60
    return jsonify({"time": f"{h:02d}:{m:02d}:{s:02d}"})

# API: 졸음 감지 여부
@app.route("/detect_drowsiness")
def detect_drowsiness():
    return jsonify({"drowsy": drowsiness_detected, "reason": drowsy_reason})

# API: 시간 업데이트
@app.route("/update_time", methods=["POST"])
def update_time():
    global elapsed_time
    data = request.json
    t = data.get("time", "00:00:00")
    h, m, s = map(int, t.split(":"))
    elapsed_time = h * 3600 + m * 60 + s
    print(f"[RECEIVED TIME] {t}")
    return "time updated"

# 실행
if __name__ == "__main__":
    threading.Thread(target=drowsiness_detection_loop, daemon=True).start()
    threading.Thread(target=monitor_buttons, daemon=True).start()
    threading.Thread(target=timer_loop, daemon=True).start()
    app.run(host="0.0.0.0", port=5000)
